"use strict";
/**
 * @packageDocumentation
 * @module Utils-HelperFunctions
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.costExportTx = exports.calcBytesCost = exports.costImportTx = exports.NodeIDStringToBuffer = exports.bufferToNodeIDString = exports.privateKeyStringToBuffer = exports.bufferToPrivateKeyString = exports.UnixNow = exports.MaxWeightFormula = exports.getPreferredHRP = void 0;
const constants_1 = require("./constants");
const bn_js_1 = __importDefault(require("bn.js"));
const bintools_1 = __importDefault(require("../utils/bintools"));
const errors_1 = require("../utils/errors");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
function getPreferredHRP(networkID = undefined) {
    if (networkID in constants_1.NetworkIDToHRP) {
        return constants_1.NetworkIDToHRP[`${networkID}`];
    }
    else if (typeof networkID === "undefined") {
        return constants_1.NetworkIDToHRP[`${constants_1.DefaultNetworkID}`];
    }
    return constants_1.FallbackHRP;
}
exports.getPreferredHRP = getPreferredHRP;
function MaxWeightFormula(staked, cap) {
    return bn_js_1.default.min(staked.mul(new bn_js_1.default(5)), cap);
}
exports.MaxWeightFormula = MaxWeightFormula;
/**
 * Function providing the current UNIX time using a {@link https://github.com/indutny/bn.js/|BN}.
 */
function UnixNow() {
    return new bn_js_1.default(Math.round(new Date().getTime() / 1000));
}
exports.UnixNow = UnixNow;
/**
 * Takes a private key buffer and produces a private key string with prefix.
 *
 * @param pk A {@link https://github.com/feross/buffer|Buffer} for the private key.
 */
function bufferToPrivateKeyString(pk) {
    return `PrivateKey-${bintools.cb58Encode(pk)}`;
}
exports.bufferToPrivateKeyString = bufferToPrivateKeyString;
/**
 * Takes a private key string and produces a private key {@link https://github.com/feross/buffer|Buffer}.
 *
 * @param pk A string for the private key.
 */
function privateKeyStringToBuffer(pk) {
    if (!pk.startsWith("PrivateKey-")) {
        throw new errors_1.PrivateKeyError("Error - privateKeyStringToBuffer: private keys must start with 'PrivateKey-'");
    }
    const pksplit = pk.split("-");
    return bintools.cb58Decode(pksplit[pksplit.length - 1]);
}
exports.privateKeyStringToBuffer = privateKeyStringToBuffer;
/**
 * Takes a nodeID buffer and produces a nodeID string with prefix.
 *
 * @param pk A {@link https://github.com/feross/buffer|Buffer} for the nodeID.
 */
function bufferToNodeIDString(pk) {
    return `NodeID-${bintools.cb58Encode(pk)}`;
}
exports.bufferToNodeIDString = bufferToNodeIDString;
/**
 * Takes a nodeID string and produces a nodeID {@link https://github.com/feross/buffer|Buffer}.
 *
 * @param pk A string for the nodeID.
 */
function NodeIDStringToBuffer(pk) {
    if (!pk.startsWith("NodeID-")) {
        throw new errors_1.NodeIdError("Error - privateNodeIDToBuffer: nodeID must start with 'NodeID-'");
    }
    const pksplit = pk.split("-");
    return bintools.cb58Decode(pksplit[pksplit.length - 1]);
}
exports.NodeIDStringToBuffer = NodeIDStringToBuffer;
function costImportTx(tx) {
    let bytesCost = calcBytesCost(tx.toBuffer().byteLength);
    const importTx = tx.getTransaction();
    importTx.getImportInputs().forEach((input) => {
        const inCost = input.getCost();
        bytesCost += inCost;
    });
    const fixedFee = 10000;
    return bytesCost + fixedFee;
}
exports.costImportTx = costImportTx;
function calcBytesCost(len) {
    return len * constants_1.Defaults.network[1].EVM.txBytesGas;
}
exports.calcBytesCost = calcBytesCost;
function costExportTx(tx) {
    const bytesCost = calcBytesCost(tx.toBuffer().byteLength);
    const exportTx = tx.getTransaction();
    const numSigs = exportTx.getInputs().length;
    const sigCost = numSigs * constants_1.Defaults.network[1].EVM.costPerSignature;
    const fixedFee = 10000;
    return bytesCost + sigCost + fixedFee;
}
exports.costExportTx = costExportTx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVyZnVuY3Rpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3V0aWxzL2hlbHBlcmZ1bmN0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7QUFFSCwyQ0FLb0I7QUFDcEIsa0RBQXNCO0FBRXRCLGlFQUF3QztBQUN4Qyw0Q0FBOEQ7QUFHOUQ7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBYSxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFBO0FBRWpELFNBQWdCLGVBQWUsQ0FBQyxZQUFvQixTQUFTO0lBQzNELElBQUksU0FBUyxJQUFJLDBCQUFjLEVBQUU7UUFDL0IsT0FBTywwQkFBYyxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsQ0FBQTtLQUN0QztTQUFNLElBQUksT0FBTyxTQUFTLEtBQUssV0FBVyxFQUFFO1FBQzNDLE9BQU8sMEJBQWMsQ0FBQyxHQUFHLDRCQUFnQixFQUFFLENBQUMsQ0FBQTtLQUM3QztJQUNELE9BQU8sdUJBQVcsQ0FBQTtBQUNwQixDQUFDO0FBUEQsMENBT0M7QUFFRCxTQUFnQixnQkFBZ0IsQ0FBQyxNQUFVLEVBQUUsR0FBTztJQUNsRCxPQUFPLGVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0FBQzNDLENBQUM7QUFGRCw0Q0FFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTztJQUNyQixPQUFPLElBQUksZUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFBO0FBQ3hELENBQUM7QUFGRCwwQkFFQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxFQUFVO0lBQ2pELE9BQU8sY0FBYyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUE7QUFDaEQsQ0FBQztBQUZELDREQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLEVBQVU7SUFDakQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEVBQUU7UUFDakMsTUFBTSxJQUFJLHdCQUFlLENBQ3ZCLDhFQUE4RSxDQUMvRSxDQUFBO0tBQ0Y7SUFDRCxNQUFNLE9BQU8sR0FBYSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQ3ZDLE9BQU8sUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3pELENBQUM7QUFSRCw0REFRQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxFQUFVO0lBQzdDLE9BQU8sVUFBVSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUE7QUFDNUMsQ0FBQztBQUZELG9EQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLEVBQVU7SUFDN0MsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDN0IsTUFBTSxJQUFJLG9CQUFXLENBQ25CLGlFQUFpRSxDQUNsRSxDQUFBO0tBQ0Y7SUFDRCxNQUFNLE9BQU8sR0FBYSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQ3ZDLE9BQU8sUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3pELENBQUM7QUFSRCxvREFRQztBQUVELFNBQWdCLFlBQVksQ0FBQyxFQUFjO0lBQ3pDLElBQUksU0FBUyxHQUFXLGFBQWEsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDL0QsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLGNBQWMsRUFBYyxDQUFBO0lBQ2hELFFBQVEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUF3QixFQUFRLEVBQUU7UUFDcEUsTUFBTSxNQUFNLEdBQVcsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFBO1FBQ3RDLFNBQVMsSUFBSSxNQUFNLENBQUE7SUFDckIsQ0FBQyxDQUFDLENBQUE7SUFDRixNQUFNLFFBQVEsR0FBVyxLQUFLLENBQUE7SUFDOUIsT0FBTyxTQUFTLEdBQUcsUUFBUSxDQUFBO0FBQzdCLENBQUM7QUFURCxvQ0FTQztBQUVELFNBQWdCLGFBQWEsQ0FBQyxHQUFXO0lBQ3ZDLE9BQU8sR0FBRyxHQUFHLG9CQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUE7QUFDakQsQ0FBQztBQUZELHNDQUVDO0FBRUQsU0FBZ0IsWUFBWSxDQUFDLEVBQWM7SUFDekMsTUFBTSxTQUFTLEdBQVcsYUFBYSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUNqRSxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsY0FBYyxFQUFjLENBQUE7SUFDaEQsTUFBTSxPQUFPLEdBQVcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLE1BQU0sQ0FBQTtJQUNuRCxNQUFNLE9BQU8sR0FBVyxPQUFPLEdBQUcsb0JBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFBO0lBQzFFLE1BQU0sUUFBUSxHQUFXLEtBQUssQ0FBQTtJQUM5QixPQUFPLFNBQVMsR0FBRyxPQUFPLEdBQUcsUUFBUSxDQUFBO0FBQ3ZDLENBQUM7QUFQRCxvQ0FPQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICogQG1vZHVsZSBVdGlscy1IZWxwZXJGdW5jdGlvbnNcclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIE5ldHdvcmtJRFRvSFJQLFxyXG4gIERlZmF1bHROZXR3b3JrSUQsXHJcbiAgRmFsbGJhY2tIUlAsXHJcbiAgRGVmYXVsdHNcclxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxyXG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCJcclxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlci9cIlxyXG5pbXBvcnQgQmluVG9vbHMgZnJvbSBcIi4uL3V0aWxzL2JpbnRvb2xzXCJcclxuaW1wb3J0IHsgUHJpdmF0ZUtleUVycm9yLCBOb2RlSWRFcnJvciB9IGZyb20gXCIuLi91dGlscy9lcnJvcnNcIlxyXG5pbXBvcnQgeyBFeHBvcnRUeCwgSW1wb3J0VHgsIFRyYW5zZmVyYWJsZUlucHV0LCBVbnNpZ25lZFR4IH0gZnJvbSBcIi4uL2FwaXMvZXZtXCJcclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCBiaW50b29sczogQmluVG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlZmVycmVkSFJQKG5ldHdvcmtJRDogbnVtYmVyID0gdW5kZWZpbmVkKTogc3RyaW5nIHtcclxuICBpZiAobmV0d29ya0lEIGluIE5ldHdvcmtJRFRvSFJQKSB7XHJcbiAgICByZXR1cm4gTmV0d29ya0lEVG9IUlBbYCR7bmV0d29ya0lEfWBdXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV0d29ya0lEID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICByZXR1cm4gTmV0d29ya0lEVG9IUlBbYCR7RGVmYXVsdE5ldHdvcmtJRH1gXVxyXG4gIH1cclxuICByZXR1cm4gRmFsbGJhY2tIUlBcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE1heFdlaWdodEZvcm11bGEoc3Rha2VkOiBCTiwgY2FwOiBCTik6IEJOIHtcclxuICByZXR1cm4gQk4ubWluKHN0YWtlZC5tdWwobmV3IEJOKDUpKSwgY2FwKVxyXG59XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gcHJvdmlkaW5nIHRoZSBjdXJyZW50IFVOSVggdGltZSB1c2luZyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFVuaXhOb3coKTogQk4ge1xyXG4gIHJldHVybiBuZXcgQk4oTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApKVxyXG59XHJcblxyXG4vKipcclxuICogVGFrZXMgYSBwcml2YXRlIGtleSBidWZmZXIgYW5kIHByb2R1Y2VzIGEgcHJpdmF0ZSBrZXkgc3RyaW5nIHdpdGggcHJlZml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIHByaXZhdGUga2V5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvUHJpdmF0ZUtleVN0cmluZyhwazogQnVmZmVyKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFByaXZhdGVLZXktJHtiaW50b29scy5jYjU4RW5jb2RlKHBrKX1gXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhIHByaXZhdGUga2V5IHN0cmluZyBhbmQgcHJvZHVjZXMgYSBwcml2YXRlIGtleSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfS5cclxuICpcclxuICogQHBhcmFtIHBrIEEgc3RyaW5nIGZvciB0aGUgcHJpdmF0ZSBrZXkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJpdmF0ZUtleVN0cmluZ1RvQnVmZmVyKHBrOiBzdHJpbmcpOiBCdWZmZXIge1xyXG4gIGlmICghcGsuc3RhcnRzV2l0aChcIlByaXZhdGVLZXktXCIpKSB7XHJcbiAgICB0aHJvdyBuZXcgUHJpdmF0ZUtleUVycm9yKFxyXG4gICAgICBcIkVycm9yIC0gcHJpdmF0ZUtleVN0cmluZ1RvQnVmZmVyOiBwcml2YXRlIGtleXMgbXVzdCBzdGFydCB3aXRoICdQcml2YXRlS2V5LSdcIlxyXG4gICAgKVxyXG4gIH1cclxuICBjb25zdCBwa3NwbGl0OiBzdHJpbmdbXSA9IHBrLnNwbGl0KFwiLVwiKVxyXG4gIHJldHVybiBiaW50b29scy5jYjU4RGVjb2RlKHBrc3BsaXRbcGtzcGxpdC5sZW5ndGggLSAxXSlcclxufVxyXG5cclxuLyoqXHJcbiAqIFRha2VzIGEgbm9kZUlEIGJ1ZmZlciBhbmQgcHJvZHVjZXMgYSBub2RlSUQgc3RyaW5nIHdpdGggcHJlZml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIG5vZGVJRC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUb05vZGVJRFN0cmluZyhwazogQnVmZmVyKTogc3RyaW5nIHtcclxuICByZXR1cm4gYE5vZGVJRC0ke2JpbnRvb2xzLmNiNThFbmNvZGUocGspfWBcclxufVxyXG5cclxuLyoqXHJcbiAqIFRha2VzIGEgbm9kZUlEIHN0cmluZyBhbmQgcHJvZHVjZXMgYSBub2RlSUQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0uXHJcbiAqXHJcbiAqIEBwYXJhbSBwayBBIHN0cmluZyBmb3IgdGhlIG5vZGVJRC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOb2RlSURTdHJpbmdUb0J1ZmZlcihwazogc3RyaW5nKTogQnVmZmVyIHtcclxuICBpZiAoIXBrLnN0YXJ0c1dpdGgoXCJOb2RlSUQtXCIpKSB7XHJcbiAgICB0aHJvdyBuZXcgTm9kZUlkRXJyb3IoXHJcbiAgICAgIFwiRXJyb3IgLSBwcml2YXRlTm9kZUlEVG9CdWZmZXI6IG5vZGVJRCBtdXN0IHN0YXJ0IHdpdGggJ05vZGVJRC0nXCJcclxuICAgIClcclxuICB9XHJcbiAgY29uc3QgcGtzcGxpdDogc3RyaW5nW10gPSBway5zcGxpdChcIi1cIilcclxuICByZXR1cm4gYmludG9vbHMuY2I1OERlY29kZShwa3NwbGl0W3Brc3BsaXQubGVuZ3RoIC0gMV0pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3N0SW1wb3J0VHgodHg6IFVuc2lnbmVkVHgpOiBudW1iZXIge1xyXG4gIGxldCBieXRlc0Nvc3Q6IG51bWJlciA9IGNhbGNCeXRlc0Nvc3QodHgudG9CdWZmZXIoKS5ieXRlTGVuZ3RoKVxyXG4gIGNvbnN0IGltcG9ydFR4ID0gdHguZ2V0VHJhbnNhY3Rpb24oKSBhcyBJbXBvcnRUeFxyXG4gIGltcG9ydFR4LmdldEltcG9ydElucHV0cygpLmZvckVhY2goKGlucHV0OiBUcmFuc2ZlcmFibGVJbnB1dCk6IHZvaWQgPT4ge1xyXG4gICAgY29uc3QgaW5Db3N0OiBudW1iZXIgPSBpbnB1dC5nZXRDb3N0KClcclxuICAgIGJ5dGVzQ29zdCArPSBpbkNvc3RcclxuICB9KVxyXG4gIGNvbnN0IGZpeGVkRmVlOiBudW1iZXIgPSAxMDAwMFxyXG4gIHJldHVybiBieXRlc0Nvc3QgKyBmaXhlZEZlZVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY0J5dGVzQ29zdChsZW46IG51bWJlcik6IG51bWJlciB7XHJcbiAgcmV0dXJuIGxlbiAqIERlZmF1bHRzLm5ldHdvcmtbMV0uRVZNLnR4Qnl0ZXNHYXNcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvc3RFeHBvcnRUeCh0eDogVW5zaWduZWRUeCk6IG51bWJlciB7XHJcbiAgY29uc3QgYnl0ZXNDb3N0OiBudW1iZXIgPSBjYWxjQnl0ZXNDb3N0KHR4LnRvQnVmZmVyKCkuYnl0ZUxlbmd0aClcclxuICBjb25zdCBleHBvcnRUeCA9IHR4LmdldFRyYW5zYWN0aW9uKCkgYXMgRXhwb3J0VHhcclxuICBjb25zdCBudW1TaWdzOiBudW1iZXIgPSBleHBvcnRUeC5nZXRJbnB1dHMoKS5sZW5ndGhcclxuICBjb25zdCBzaWdDb3N0OiBudW1iZXIgPSBudW1TaWdzICogRGVmYXVsdHMubmV0d29ya1sxXS5FVk0uY29zdFBlclNpZ25hdHVyZVxyXG4gIGNvbnN0IGZpeGVkRmVlOiBudW1iZXIgPSAxMDAwMFxyXG4gIHJldHVybiBieXRlc0Nvc3QgKyBzaWdDb3N0ICsgZml4ZWRGZWVcclxufVxyXG4iXX0=